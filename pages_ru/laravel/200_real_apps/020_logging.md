---
title: Логирование
permalink: laravel/200_real_apps/020_logging.html
examples_initial: examples/laravel/010_basic_app
examples: examples/laravel/020_logging
description: |
  В этой главе мы настроим логирование приложения в Kubernetes и разберём его особенности, а также сделаем структурированный формат логов для последующего парсинга системами сбора и анализа логов.
---

## Вывод логов в stdout

У задеплоенных в Kubernetes приложений логи всегда должны отправляться в [stdout/stderr](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8#%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B9_%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4). Отправка логов в стандартные потоки делает логи доступными для Kubernetes и систем сбора логов, помогает избегать потерь логов при пересоздании контейнеров, а также переполнения логами дисков Kubernetes-узлов при сохранении их в файлах внутри контейнеров.

По умолчанию Laravel не пишет логи ни в stdout, ни в stderr, а сохраняет их в файл. При использовании стандартной конфигурации необходимо использовать переменную окружения `LOG_CHANNEL=stderr`, чтобы включить вывод всех логов (в т.ч. ошибок) в stderr.

## Формат логов

Логи php-fpm и Laravel-приложения по умолчанию представляют собой обычный текст:
```shell
[07-Oct-2021 12:36:42] NOTICE: fpm is running, pid 1
[07-Oct-2021 12:36:42] NOTICE: ready to handle connections
[2021-10-07 14:06:17] production.INFO: Ping request.
- -  07/Oct/2021:14:06:17 +0000 "GET /index.php" 200
```

Обратите внимание, что сообщения от php-fpm и laravel-приложения имеют разный формат, а так же в логе вместо реального запроса `/ping` отображается `SCRIPT_FILENAME` из параметров fastcgi. К тому-же такой текст парсить системами сбора и анализа логов будет очень непросто.

Эту проблему можно решить, если отдавать логи в структурированном формате вроде JSON: система сбора логов обычно очень просто распознает и разбирает JSON-логи, а также корректно обрабатывает логи/сообщения в неожиданных, неструктурированных форматах, которые могут вклиниваться между логами в JSON-формате.

Чтобы laravel начал отдавать логи в JSON вместо plain text, в стандартной конфигурации, необходимо использовать переменную окружения `LOG_STDERR_FORMATTER=Monolog\\Formatter\\JsonFormatter`.

Так же зададим JSON формат и для access-логов php-fpm:
{% include snippetcut_example path=".werf/zzz-php-fpm-config.conf" syntax="ini" examples=page.examples %}

> _Добавление поддержки тегирования логов выходит за рамки этого руководства, но может быть реализовано при необходимости._

## Управление уровнем логирования

По умолчанию уровень логирования приложения задан как `debug`. Но в production вы скорее всего захотите `info`.

В то же время при диагностике проблем в production может помочь переключение логирования с `info` на `debug` для получения дополнительной отладочной информации. И если приложение работает в большом количестве реплик, то переключать все реплики приложения на `debug` может быть не лучшей идеей, т.к. это может сказаться на безопасности, а также сильно увеличить нагрузку на компоненты, ответственные за сбор, хранение и анализ логов.

Решить эту проблему можно запустив рядом с уже существующим Deployment'ом приложения, у которого уровень логирования `info`, точно такой же Deployment, но в одной реплике и с уровнем логирования `debug`. Также для этого нового Deployment'а мы можем отключить централизованный сбор логов, если таковой имеется. Всё это в совокупности позволит нам не перегружать системы сбора логов и не сохранять в них потенциально небезопасные отладочные логи.

Уровень логирования по-умолчанию выставляем через переменную окружения `LOG_LEVEL` вот так:
{% include snippetcut_example path=".helm/templates/deployment.yaml" syntax="yaml" snippet="log-level" examples=page.examples %}

Если переменная окружения не указана, будет использован стандартный уровень `debug`.

## Отображение логов при деплое с werf

По умолчанию werf при деплое показывает логи всех контейнеров приложения и делает это до тех пор, пока они не перейдут в состояние `Ready`. 
С помощью специальных werf-аннотаций можно организовать фильтрацию логов и выводить только те строки, которые удовлетворяют заданным шаблонам.
В дополнение к этому можно настроить вывод логов только для определённых контейнеров.

К примеру, следующим образом можно отключить вывод контейнера с именем `container_name` при выкате:
```yaml
annotations:
  werf.io/skip-logs-for-containers: container_name
```

А в следующем примере показывается, как можно выводить только те строки, которые удовлетворяют заданному регулярному выражению:
```yaml
annotations:
  werf.io/log-regex: ".*ERROR.*"
```

Список всех доступных аннотаций можно посмотреть [здесь](https://ru.werf.io/documentation/v1.2/reference/deploy_annotations.html).

> _Эти аннотации влияют только на то, как логи отображаются при деплое с werf. Они не оказывают никакого влияния на развертываемое приложение или его конфигурацию. Логи по-прежнему доступны в stdout/stderr контейнера в первоначальном виде._

## Проверка работоспособности

Теперь попробуем развернуть приложение:
```shell
werf converge --repo <имя пользователя Docker Hub>/werf-guide-app
```

Ожидаемый результат:
{% include snippetcut_example path="werf-converge.log" syntax="shell" examples=page.examples %}

Выполним пару запросов для генерации логов:
```shell
curl http://werf-guide-app/ping       # вернёт "pong" и код возврата 200
curl http://werf-guide-app/not_found  # ничего не вернёт, только код возврата 404
```

Проверим логи:
```shell
kubectl logs deploy/werf-guide-app -c backend
```

Ожидаемый результат:
```shell
[07-Oct-2021 14:45:35] NOTICE: fpm is running, pid 1
[07-Oct-2021 14:45:35] NOTICE: ready to handle connections
{"message":"Ping request.","context":{},"level":200,"level_name":"INFO","channel":"production","datetime":"2021-10-07T14:48:13.808904+00:00","extra":{}}
{"time_local":"2021-10-07T14:48:13+0000","client_ip":"192.168.49.1","remote_addr":"-","remote_user":"","request":"GET /ping HTTP/1.1","status":"200","body_bytes_sent":"0","request_time":"0.171","http_referrer":"-","http_user_agent":"curl/7.64.1","request_id":"52e2b175bb93949f2901cd27f297e057"}
{"time_local":"2021-10-07T14:48:18+0000","client_ip":"192.168.49.1","remote_addr":"-","remote_user":"","request":"GET /not_found HTTP/1.1","status":"404","body_bytes_sent":"0","request_time":"0.039","http_referrer":"-","http_user_agent":"curl/7.64.1","request_id":"a7d81d60362b0597f8992e290cd78a10"}
```

Как видим, логи теперь отдаются в JSON и легко могут быть распарсены. Некоторые логи по-прежнему отдаются обычным текстом, но главное, что системы сбора логов теперь не будут пытаться распарсить логи приложения и часть логов php-fpm так, как будто они имеют один формат: JSON-логи сохранятся отдельно и для них будет возможен поиск/фильтрация только по нужным полям.
