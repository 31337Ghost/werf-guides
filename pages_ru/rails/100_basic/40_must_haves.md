---
title: Необходимо знать
permalink: rails/100_basic/40_must_haves.html
---

В данном разделе приведем основную информацию, чтобы вам было комфортно и вы чувствовали себя уверенно при использовании werf:

- **Принципы работы с исходным кодом и что такое гитерминизм** (giterminism) — они обеспечивают надежность и гарантию воспроизводимости, а также унифицируют все процессы.
- Объясним как в werf **тегируются образы** и о том, надо ли беспокоиться о тегах, чтобы организовать сборку и деплой (нет, не надо).
- Расскажем про **Релиз** и его **отладку**.
- Объясним как освободить **место в хранилище образов**, которое рано или поздно начнет заканчиваться, как следствие доработок приложения и регулярных релизов.

## Работа с исходным кодом и гитерминизм

Зачастую часть настроек, влияющих на конфигурацию выкаченного приложения, формируется на основании «внешних» данных: окружения, в котором выполняется сборка и выкат, предустановленных переменных окружения и сгенерированных файлов, использования внешних ресурсов и т.д. Это напрямую влияет на невозможность **гарантировать воспроизводимость** состояния приложения.

{% offtopic title="А зачем нам воспроизводимость?" %}
Если в любой момент можно быстро воспроизвести состояние приложения, то проще заниматься **отладкой**, проще **развернуть копию проекта** (как для разработки, так и для организации нового стенда) и мы можем увереннее опираться на результаты тестирования на том или ином стенде (т.к. у нас меньше скрытых параметров, влияющих на состояние).

Воспроизводимость фундаментально необходима для реализации подхода [infrastructure as code](https://en.wikipedia.org/wiki/Infrastructure_as_code) и immutable infrastructure.
{% endofftopic %}

Чтобы **гарантировать** воспроизводимость, werf следует принципам гитерминизма, детерминируя работу с проектом файлами текущего git-состояния (HEAD коммита). По умолчанию werf не позволяет использовать некоммитнутые файлы в конфигурации и сборочном контексте собираемых образов, а также исключает функционал, потенциально имеющий внешние зависимости.

Мы настоятельно рекомендуем следовать этому подходу, но при необходимости можно явно ослабить ограничения гитерминизма, а также включить функционал, требующий осмысленного использования, с конфигурацией [werf-giterminism.yaml]({{ site.url }}/documentation/reference/werf_giterminism_yaml.html).

При отладке и разработке, изменение файлов проекта может доставлять неудобства за счёт необходимости создания промежуточных коммитов. В этих случаях рекомендуется работать в [режиме разработчика](#dev-режим).

Подробнее про гитерминизм можно прочитать в документации [werf]({{ site.url }}/documentation/advanced/giterminism.html).

### dev-режим

Режим разработчика позволяет ослабить ограничения гитерминизма и работать с некоммитнутыми файлами.
Режим активируется опцией `--dev` или соответствующей переменной окружения `WERF_DEV`. Поддерживается два режима работы, которые регулируются опцией `--dev-mode` (по умолчанию _simple_):

- _simple_: для работы с состоянием worktree git-репозитория проекта;
- _strict_: для работы с [состоянием index](http://shafiul.github.io/gitbook/1_the_git_index.html), в git-репозитории проекта.

Стоит отметить, что новые файлы (_untracked_) должны всегда добавляться в index вручную (единоразовая операция, которая выполняется командой `git add` для каждого вновь добавленного файла).

### follow-режим

Режим follow позволяет перезапускать команду при изменении состояния git:

- команда перезапускается при создании нового коммита;
- совместно с [dev-режимом](#dev-режим) (`--dev`) дополнительно отслеживается состояние index git-репозитория, для перезапуска команды достаточно добавить новые изменения в index (`git add`).

Режим активируется опцией `--follow` или соответствующей переменной окружения `WERF_FOLLOW`.

## Сборка и тегирование образов

### Сборка

При использовании классического варианта сборки при помощи Docker необходимо использовать как минимум 2 команды: `docker build и docker tag` а затем еще и опубликовать вновь собранный образ в registry при помощи `docker push`.
В werf же это делается в рамках одной команды `werf build`.
Так же в werf реализована [параллельная сборка]({{ site.url }}/documentation/v1.2/internals/build_process.html#параллельная-сборка), когда независимые образы собираются одновременно, а так же [распределенная сборка]({{ site.url }}/documentation/v1.2/internals/build_process.html#параллельная-сборка), когда werf собирает каждый слой разными сборщиками, при этом за счет механизмов синхронизации и блокировок они эффективно переиспользуют общие слои и не нарушают воспроизводимость всех сборок.

### Тегирование образов

Если бы вы строили процесс деплоя без werf, вручную, то вам бы пришлось задавать строгие правила тегирования образов и соблюдать их (поверьте, это [очень непросто](https://www.youtube.com/watch?v=oh4N2wBJCc8)). Однако вы могли заметить, что в случае werf в чартах используется конструкция вида {% raw %}`image: {{ .Values.werf.image.basicapp }}`{% endraw %}:

{% raw %}
```yaml
      - name: basicapp
        command: ["bundle","exec", "puma"]
        image: {{ .Values.werf.image.basicapp }}
```
{% endraw %}

**Вам нет необходимости заботиться о правилах тегирования**: если что-то изменилось в коде — werf самостоятельно инициирует пересборку необходимого образа, загрузит полученный образ со служебными тегами в registry и подставит этот образ в шаблоны. Для того, чтобы всё это корректно работало, werf хранит в registry метаданные и отслеживает содержимое файлов в Git-репозитории.

{% offtopic title="Как это всё работает?" %}
werf реализует тегирование, которое называется content-based (т.е. основанное на содержимом): образы меняются и выкатываются автоматически, если меняется состояние контента в Git. И, что важно, образы не меняются от коммита к коммиту и не происходит лишних перевыкатов, если состояние контента в GIt не поменялось.

При организации деплоя без использования werf зачастую приходится формализовать принципы, по которым именуются образы в registry. В нашем случае нет необходимости думать об этом: werf берёт организацию тегирования на себя.

Если кратко, werf рассчитывает контрольную сумму файлов, добавляемых в образы, и на основании этого генерирует теги для образа. Однако, он это делает таким образом, чтобы несколько сборок, собирающихся параллельно (в том числе на разных серверах), не конфликтовали. Для этого используется подход, основанный на идеях [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control) и [optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control).

Подробнее о том, как хранятся данные в registry, можно почитать [в документации werf]({{ site.url }}/documentation/internals/stages_and_storage.html). Там написано, как устроен процесс сборки, как учитываются зависимости между стадиями сборки, а также — как устроено именование полученных образов.
{% endofftopic %}

## Релизы и helm

werf использует helm для деплоя приложения.
[Helm-чарт](https://helm.sh/docs/topics/charts/) — это набор файлов, описывающий связанный набор объектов Kubernetes. Когда чарт выкатывается в кластер в определённое окружение — создаётся _релиз_.

{% offtopic title="Где почитать подробнее" %}
В [документации werf]({{ site.url }}/documentation/v1.2/advanced/helm/releases/release.html) есть подробное описание того, как устроена работа с релизами, их хранение и именование.
{% endofftopic %}

werf всецело использует политику гитерминизма во время работы с релизами.
При работе с релизами Helm реализует механику [3-way merge](https://helm.sh/docs/faq/#improved-upgrade-strategy-3-way-strategic-merge-patches), т.е. изменения, внесённые в кластер вручную и противоречащие тому, что описано в Git, будут приведены к последнему. Обратите внимание, что внесённые вручную изменения, не противоречащие Git, остаются не под контролем Helm и werf.

werf создает релизы самостоятельно, но если вы хотите самостоятельно работать с релизами, можете использовать команды `werf helm <...>`.

### Посмотреть, что установлено

Релизы показывают, **что конкретно в кластере установлено, в каком окружении** и в каком состоянии оно находится.

Чтобы посмотреть список релизов или найти, как называется нужный вам релиз, воспользуйтесь CLI-командой [`werf helm list -A`]({{ site.url }}/documentation/reference/cli/werf_helm_list.html).

### Удалить лишнее

Чтобы удалить релиз приложения из Kubernetes, воспользуйтесь [`werf dismiss`]({{ site.url }}/documentation/reference/cli/werf_dismiss.html).

### Отладка установки

Зачастую возникают сложности при выкате релиза из-за ошибок, допущенных при написании чартов. Отладить такие проблемы помогает команда [`werf render`]({{ site.url }}/documentation/reference/cli/werf_render.html).

`werf render` проводит весь цикл сборки и генерации чартов и, вместо деплоя полученного релиза в Kubernetes, выводит полученные чарты. Это «тяжёлая» операция, показывающая конечный результат со всеми реальными подставленными значениями.

_Обратите внимание, что, как и все другие команды, `werf render` работает только с коммитнутыми в Git файлами, но поддерживает режим `--dev`._

## Очистка

Со временем в хранилище (локально или в registry) может накопиться множество данных. Есть две группы команд, которые занимаются очисткой, но имеют разное предназначение: `werf cleanup` и `werf purge` (подробнее можно прочитать [в документации]({{ site.url }}/documentation/advanced/cleanup.html)).
При этом первая работает только с данными в registry, а вторая со всем, что касается werf.

### werf cleanup

Для регулярной очистки registry от неактуальных данных есть безопасная команда [`werf cleanup`]({{ site.url }}/documentation/reference/cli/werf_cleanup.html). Она безопасно удаляет образы, которые более не требуются, с помощью продвинутого алгоритма, учитывающего Git-историю, содержимое registry и состояние кластера, соответственно.
Команда используется с ключом `--repo <reponame>` для очистки данных определенного project.

Для очистки хоста от неактуальных данных, связанных с werf, используется [`werf host cleanup`]({{ site.url }}/documentation/v1.2/advanced/cleanup.html#очистка-неактуальных-данных-1)

В главе [«Работа с инфраструктурой»] ({{ site.url }}/guides/nodejs/400_infra.html) мы будем настраивать регулярную очистку registry по расписанию, используя возможности CI-системы.

### werf purge

Если есть необходимость освободить место на диске, удалив все образы и другие данные, следует использовать [`werf host purge`]({{ site.url }}/documentation/reference/cli/werf_host_purge.html)

Для полного удаления всего, что связано werf на хосте следует использовать [`werf purge`]({{ site.url }}/documentation/reference/cli/werf_purge.html) — НЕБЕЗОПАСНАЯ КОМАНДА, которая удаляет все образы!